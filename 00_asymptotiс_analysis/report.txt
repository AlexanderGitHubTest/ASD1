0. Задание.
Попробуйте оценить какие-нибудь свои или чужие программы, которые выполняют объёмную вычислительную работу -- какова мера их сложности, как сильно растёт время их работы по мере увеличения входных данных? Напишите небольшой отчёт.

1. Выполнение задания.

1.1. Решил взять задачу, которую решал недавно на codewars. В больших программах много всякого, а здесь просто функция, которая принимает одно число на вход и выдает одно число.

1.2. Задание с codewars:
The squarefree part of a positive integer is the largest divisor of that integer which itself has no square factors (other than 1). For example, the squareefree part of 12 is 6, since the only larger divisor is 12, and 12 has a square factor (namely, 4).

Your challenge, should you choose to accept it, is to implement a squareFreePart function which accepts a number n and returns the squarefree part of n.

In the case that n = 1, your function should return 1. The input will always be a strictly positive integer.

Here are some examples (input ---> output:

 2  ---> 2
 4  ---> 2
 24 --->  6 (since any larger divisor is divisible by 4, which is a square)

1.3. Моё решение - при решении был приоритет скорости, поэтому решение, явно, сильно не оптимальное, но все тесты проходит.
def square_free_part(n):
    divisors = []
    if n == 1:
        return 1
    else:
        for i in range(2,n):
            if n % i == 0: divisors.append(i)
        divisors.append(n)
        for i, divisor in enumerate(divisors):
            sqrt_ = int(divisor ** 0.5)
            if sqrt_ * sqrt_ == divisor:
                for j, divisor2 in enumerate(divisors):
                    if j>=i and divisor2 % divisor == 0: divisors[j] = divisor2 // divisor
        return max(divisors)

1.4. Оценка O(f(x)) ("О большое") - рассуждения.
Фактически в функции делаю простой цикл, а потом вложенный (цикл в цикле).
Но первый цикл делаю по всему n (хотя хватит n//2 пройти - уже вижу, либо есть какой-то более быстрый алгоритм получения делителей числа).
Второй цикл прохожу по делителям, то есть каждый проход меньше, чем n, но как корректно посчитать - не могу быстро оценить - это математическая задача.

1.5. Оценка O(f(x)) ("О большое") - результат.
Считаю, что асимптотическая сложность: О(n^2), что не очень хорошо.

1.6. Рассмотрю решение лидера:
def square_free_part(n):
    for i in range(2, int(n ** 0.5) + 1):
        while n % (i ** 2) == 0:
            n /= i
    return n

1.7. Оценка O(f(x)) ("О большое") - рассуждения. Два вложенных цикла, но они не по всему диапазону. Верхний перебирает до корня из N. А вот нижний похож на убывающую геометрическую прогрессию. Попробовал вывести исходя из формулы суммы формулу числа членов прогрессии. Вроде как логарифм получается. Логарифм меньше, чем корень, а перемножение их даст меньше, чем N. То есть О(N). Но не уверен в этом. 

1.8. Итоги. У меня функция О(N^2), лучшая функция О(N). 

1.9. Практическое тестирование (использовал функцию perf_counter())

Замерил время для n = 1000, 10000, 100000, 1000000, 10000000
n	Моя программа, сек	Лидер, сек
1000	    0,0003982		0,0001258
10000	    0,003433		0,0001569
100000	    0,0336402		0,0003951
1000000	    0,2204964		0,0012133
10000000    2,6588416		0,0038468

Для своей функции получил чуть лучше, чем линейную зависимость (О(N)): время полного прогона при переходе с 1000 до 10000000 (в 10000 раз) увеличилось в 6700 раз.
Для функции лидера зависимость не О(1), но очень пологая: время полного прогона при переходе с 1000 до 10000000 (в 10000 раз) увеличилось всего в 30 раз.

1.10. ИТОГИ.
1.10.1. Основной вывод, что пока просто познакомился с областью. Вопросов больше, чем ответов. Как подсчитывать асимптотическую сложность в более-менее сложных программах? Как подсчитывать асимптотическую сложность на практике? Возможно, нужно не время измерять, а просто инструкции считать (это можно программно сделать). С другой стороны, на практике как раз время интересует, то есть, нужно и время проверять и обе эти величины (время и количество инструкций) как-то сводить между собой.
1.10.2. Подсчет асимптотической сложности может быть очень нетривиальным занятием и даже по данному несложному примеру вижу, что задача, скорее, математическая.
1.10.3. От алгоритма очень много зависит. Даже на такой несложной задаче на числе 10000000 получил в своём варианте 2,66 сек, а в варианте лидера 0,0038 сек. Разница в 700 (!) раз.
